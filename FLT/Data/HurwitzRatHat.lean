import FLT.Data.Hurwitz
import FLT.Data.QHat

open scoped TensorProduct

/-- The base change of the Hurwitz quaternions to ZHat. -/
noncomputable def HurwitzHat : Type := ùìû ‚äó[‚Ñ§] ZHat

namespace HurwitzHat

/-- The base change of the Hurwitz quaternions to ZHat. -/
scoped notation "ùìû^" => HurwitzHat

noncomputable instance : Ring ùìû^ := Algebra.TensorProduct.instRing

end HurwitzHat

/-- The quaternion algebra ‚Ñö + ‚Ñöi + ‚Ñöj + ‚Ñök. -/
noncomputable def HurwitzRat : Type := ‚Ñö ‚äó[‚Ñ§] ùìû

namespace HurwitzRat

/-- The quaternion algebra ‚Ñö + ‚Ñöi + ‚Ñöj + ‚Ñök. -/
scoped notation "D" => HurwitzRat

noncomputable instance : Ring D := Algebra.TensorProduct.instRing

end HurwitzRat

open scoped HurwitzRat HurwitzHat

/-- The "profinite Hurwitz quaternions" over the finite adeles of ‚Ñö; a free rank 4 module
generated by 1, i, j, and (1+i+j+k)/2. -/
noncomputable def HurwitzRatHat : Type := D ‚äó[‚Ñ§] ZHat

namespace HurwitzRatHat

/-- The "profinite Hurwitz quaternions" over the finite adeles of ‚Ñö; a free rank 4 module
generated by 1, i, j, and (1+i+j+k)/2. -/
scoped notation "D^" => HurwitzRatHat

noncomputable instance : Ring D^ := Algebra.TensorProduct.instRing

/-- The inclusion from D=‚Ñö+‚Ñöi+‚Ñöj+‚Ñök to D ‚äó ùî∏, with ùî∏ the finite adeles of ‚Ñö. -/
noncomputable abbrev j‚ÇÅ : D ‚Üí‚Çê[‚Ñ§] D^ := Algebra.TensorProduct.includeLeft
-- (Algebra.TensorProduct.assoc ‚Ñ§ ‚Ñö ùìû ZHat).symm.trans Algebra.TensorProduct.includeLeft

lemma injective_hRat :
    Function.Injective j‚ÇÅ := by
      apply_rules [ Algebra.TensorProduct.includeLeft_injective ];
      ¬∑ exact?;
      ¬∑ -- Since ‚Ñö is flat over ‚Ñ§, and the tensor product of a flat module with another module is flat, we can conclude that D is flat over ‚Ñ§.
        have h_flat : Module.Flat ‚Ñ§ (‚Ñö ‚äó[‚Ñ§] ùìû) := by
          have h_flat_Q : Module.Flat ‚Ñ§ ‚Ñö := by
            exact?
          exact?;
        exact h_flat

-- flatness

/-- The inclusion from the profinite Hurwitz quaternions to to ùî∏+ùî∏i+ùî∏j+ùî∏k,
with ùî∏ the finite adeles of ‚Ñö. -/
noncomputable abbrev j‚ÇÇ : ùìû^ ‚Üí‚Çê[‚Ñ§] D^ :=
  ((Algebra.TensorProduct.assoc ‚Ñ§ ‚Ñ§ ‚Ñö ùìû ZHat).symm : ‚Ñö ‚äó ùìû^ ‚âÉ‚Çê[‚Ñ§] D ‚äó ZHat).toAlgHom.comp
  (Algebra.TensorProduct.includeRight : ùìû^ ‚Üí‚Çê[‚Ñ§] ‚Ñö ‚äó ùìû^)

noncomputable section AristotleLemmas

lemma Hurwitz.noZeroSMulDivisors : NoZeroSMulDivisors ‚Ñ§ ùìû := by
  -- To show that ùìû is NoZeroSMulDivisors, we need to show that if z is a non-zero integer and a is a non-zero Hurwitz quaternion, then z * a is non-zero.
  have h_no_zero_smul_divisors : ‚àÄ (z : ‚Ñ§) (a : ùìû), z ‚â† 0 ‚Üí a ‚â† 0 ‚Üí z ‚Ä¢ a ‚â† 0 := by
    simp_all +decide [ mul_eq_zero, Hurwitz.ext_iff ];
  constructor;
  exact fun h => Classical.or_iff_not_imp_left.2 fun h' => Classical.not_not.1 fun h'' => h_no_zero_smul_divisors _ _ h' h'' h

lemma Hurwitz.includeRight_injective : Function.Injective (Algebra.TensorProduct.includeRight : ùìû ‚Üí ‚Ñö ‚äó[‚Ñ§] ùìû) := by
  have h_inj : NoZeroSMulDivisors ‚Ñ§ (ùìû : Type) := by
    exact?;
  -- Since ‚Ñö is flat over ‚Ñ§, the tensor product ‚Ñö ‚äó[‚Ñ§] ùìû is flat, which implies that the inclusion map is injective.
  have h_flat : Module.Flat ‚Ñ§ (ùìû : Type) := by
    exact?;
  -- Since ‚Ñö is flat over ‚Ñ§, the tensor product ‚Ñö ‚äó[‚Ñ§] ùìû is flat, which implies that the inclusion map is injective. We can use the fact that the tensor product of a flat module with any module is flat.
  have h_flat_tensor : Module.Flat ‚Ñ§ (ùìû : Type) ‚Üí Function.Injective (Algebra.TensorProduct.includeRight : ùìû ‚Üí ‚Ñö ‚äó[‚Ñ§] ùìû) := by
    intro h_flat
    have h_inj : Function.Injective (Algebra.TensorProduct.includeRight : ùìû ‚Üí ‚Ñö ‚äó[‚Ñ§] ùìû) := by
      have h_inj : Function.Injective (algebraMap ‚Ñ§ ‚Ñö) := by
        exact Int.cast_injective
      exact?;
    exact h_inj;
  exact h_flat_tensor h_flat

instance Hurwitz.instModuleFree : Module.Free ‚Ñ§ ùìû := by
  -- We'll use that ùìû is isomorphic to the ring of integers of this field.
  have h_iso : ùìû ‚âÉ‚Çó[‚Ñ§] ‚Ñ§ √ó ‚Ñ§ √ó ‚Ñ§ √ó ‚Ñ§ := by
    refine' LinearEquiv.ofBijective _ ‚ü® _, _ ‚ü©;
    refine' { .. };
    exact fun x => ‚ü® x.re, x.im_o, x.im_i, x.im_oi ‚ü©;
    all_goals norm_num [ Function.Injective, Function.Surjective ];
    ¬∑ exact?;
    ¬∑ exact fun a b c d => ‚ü® ‚ü® a, b, c, d ‚ü©, rfl, rfl, rfl, rfl ‚ü©;
  have := h_iso;
  exact Module.Free.of_equiv this.symm

end AristotleLemmas

lemma injective_zHat :
    Function.Injective j‚ÇÇ := by
      refine' ( Algebra.TensorProduct.assoc ‚Ñ§ ‚Ñ§ ‚Ñö ùìû ZHat ).symm.injective.comp _;
      -- Since $ùìû$ is free, $ùìû ‚äó[‚Ñ§] ZHat$ is flat.
      have h_flat : Module.Flat ‚Ñ§ (ùìû ‚äó[‚Ñ§] ZHat) := by
        exact?;
      -- Since ‚Ñö is flat, the tensor product with ‚Ñö preserves injectivity.
      have h_flat : Function.Injective (Algebra.TensorProduct.includeRight : ùìû ‚äó[‚Ñ§] ZHat ‚Üí ‚Ñö ‚äó[‚Ñ§] (ùìû ‚äó[‚Ñ§] ZHat)) := by
        have h_flat : Module.Flat ‚Ñ§ (ùìû ‚äó[‚Ñ§] ZHat) := h_flat
        have h_inj : Function.Injective (Int.castRingHom ‚Ñö) := by
          exact Int.cast_injective
        exact?;
      exact h_flat

-- flatness

-- should I rearrange tensors? Not sure if D^ should be (‚Ñö ‚äó ùìû) ‚äó ‚Ñ§hat or ‚Ñö ‚äó (ùìû ‚äó Zhat)
lemma canonicalForm (z : D^) : ‚àÉ (N : ‚Ñï+) (z' : ùìû^), z = j‚ÇÅ ((N‚Åª¬π : ‚Ñö) ‚äó‚Çú 1 : D) * j‚ÇÇ z' := by
  by_contra! h;
  -- Let's denote the element $z$ as $z = \sum_{i=1}^n (a_i \otimes b_i) \otimes c_i$.
  obtain ‚ü®n, a, b, c, hz‚ü© : ‚àÉ (n : ‚Ñï) (a : Fin n ‚Üí ‚Ñö) (b : Fin n ‚Üí Hurwitz) (c : Fin n ‚Üí ZHat), z = ‚àë i, ((a i : ‚Ñö) ‚äó‚Çú (b i : Hurwitz)) ‚äó‚Çú (c i : ZHat) := by
    have h_decomp : ‚àÄ z : TensorProduct ‚Ñ§ (TensorProduct ‚Ñ§ ‚Ñö Hurwitz) ZHat, ‚àÉ (n : ‚Ñï) (a : Fin n ‚Üí ‚Ñö) (b : Fin n ‚Üí Hurwitz) (c : Fin n ‚Üí ZHat), z = ‚àë i, (a i : ‚Ñö) ‚äó‚Çú (b i : Hurwitz) ‚äó‚Çú (c i : ZHat) := by
      intro z;
      induction z using TensorProduct.induction_on;
      ¬∑ exact ‚ü® 0, fun _ => 0, fun _ => 0, fun _ => 0, by norm_num ‚ü©;
      ¬∑ rename_i x y;
        induction x using TensorProduct.induction_on;
        ¬∑ exact ‚ü® 0, fun _ => 0, fun _ => 0, fun _ => 0, by simp +decide ‚ü©;
        ¬∑ exact ‚ü® 1, fun _ => ‚Äπ‚Ñö‚Ä∫, fun _ => ‚Äπùìû‚Ä∫, fun _ => y, by simp +decide ‚ü©;
        ¬∑ simp_all +decide [ add_mul, TensorProduct.add_tmul ];
          rename_i h‚ÇÅ h‚ÇÇ;
          obtain ‚ü® n‚ÇÅ, a‚ÇÅ, b‚ÇÅ, c‚ÇÅ, h‚ÇÅ ‚ü© := h‚ÇÅ; obtain ‚ü® n‚ÇÇ, a‚ÇÇ, b‚ÇÇ, c‚ÇÇ, h‚ÇÇ ‚ü© := h‚ÇÇ; exact ‚ü® n‚ÇÅ + n‚ÇÇ, Fin.append a‚ÇÅ a‚ÇÇ, Fin.append b‚ÇÅ b‚ÇÇ, Fin.append c‚ÇÅ c‚ÇÇ, by simp +decide [ Fin.sum_univ_add, h‚ÇÅ, h‚ÇÇ ] ‚ü© ;
      ¬∑ case _ hx hy => obtain ‚ü® n, a, b, c, rfl ‚ü© := hx; obtain ‚ü® m, d, e, f, rfl ‚ü© := hy; exact ‚ü® n + m, Fin.append a d, Fin.append b e, Fin.append c f, by simp +decide [ Fin.sum_univ_add ] ‚ü© ;
    exact h_decomp z;
  -- Let's choose a common denominator $N$ for the rational coefficients $a_i$.
  obtain ‚ü®N, hN‚ü© : ‚àÉ N : ‚Ñï+, ‚àÄ i : Fin n, ‚àÉ k : ‚Ñ§, a i = k / N := by
    -- Let $N$ be the least common multiple of the denominators of the rational coefficients $a_i$.
    obtain ‚ü®N, hN‚ü© : ‚àÉ N : ‚Ñï+, ‚àÄ i : Fin n, (a i).den ‚à£ N := by
      exact ‚ü® ‚ü® ‚àè i, ( a i |> Rat.den ), Finset.prod_pos fun i _ => Nat.cast_pos.mpr ( Rat.pos _ ) ‚ü©, fun i => Finset.dvd_prod_of_mem _ ( Finset.mem_univ _ ) ‚ü©;
    use N;
    intro i; specialize hN i; obtain ‚ü® k, hk ‚ü© := hN; use ( a i |> Rat.num ) * k; simp +decide [ *, Rat.num_div_den ] ;
    rw [ mul_div_mul_right _ _ ( Nat.cast_ne_zero.mpr <| by aesop_cat ), Rat.num_div_den ];
  choose k hk using hN;
  refine' h N ( ‚àë i, ( k i : ‚Ñ§ ) ‚Ä¢ ( b i ‚äó‚Çú[‚Ñ§] c i ) ) _;
  simp +decide [ hz, hk, div_eq_mul_inv, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _ ];
  refine' Finset.sum_congr rfl fun i _ => _;
  erw [ Algebra.TensorProduct.tmul_mul_tmul ] ; ring;
  erw [ Algebra.TensorProduct.tmul_mul_tmul ] ; ring;
  erw [ Algebra.TensorProduct.tmul_mul_tmul ] ; ring;
  erw [ Algebra.TensorProduct.tmul_mul_tmul ] ; ring;
  norm_num

/- Aristotle failed to find a proof. -/
lemma completed_units (z : D^À£) : ‚àÉ (u : DÀ£) (v : ùìû^À£), (z : D^) = j‚ÇÅ u * j‚ÇÇ v := sorry

end HurwitzRatHat
